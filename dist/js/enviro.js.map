{"version":3,"sources":["../../src/js/enviro.js"],"names":["canvas","ctx","spritesheet","spritesheetLoaded","warehouse","wareWidth","wareHeight","tileWidth","tileHeight","pathStart","pathEnd","currentPath","console","log","onload","document","getElementById","width","height","addEventListener","canvasClick","getContext","Image","src","loaded","createWorld","x","y","Math","random","length","floor","findPath","redraw","spriteNum","fillStyle","fillRect","drawImage","rp","e","pageX","undefined","pageY","clientX","body","scrollLeft","documentElement","clientY","scrollTop","offsetLeft","offsetTop","cell","world","abs","max","pow","sqrt","maxWalkableTileNum","worldWidth","worldHeight","worldSize","distanceFunction","ManhattanDistance","findNeighbours","Point","Goal","DiagonalDistance","EuclideanDistance","Neighbours","N","S","E","W","myN","canWalkHere","myS","myE","myW","result","push","DiagonalNeighbours","DiagonalNeighboursFree","Node","Parent","newNode","value","f","g","calculatePath","mypathStart","mypathEnd","AStar","Array","Open","Closed","myNeighbours","myNode","myPath","min","i","j","splice","reverse"],"mappings":"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","file":"enviro.js","sourcesContent":["var canvas = null;\r\nvar ctx = null;\r\nvar spritesheet = null;\r\nvar spritesheetLoaded = false;\r\n\r\nvar warehouse = [[]];\r\n\r\n//size of a warehouse\r\nvar wareWidth = 16;\r\nvar wareHeight = 16;\r\n\r\n// size of a tile in pixels\r\nvar tileWidth = 32;\r\nvar tileHeight = 32;\r\n\r\n// start and end of path\r\nvar pathStart = [wareWidth,wareHeight];\r\nvar pathEnd = [0,0];\r\nvar currentPath = [];\r\n\r\nif (typeof console == \"undefined\") var console = { log: function() {} };\r\n\r\n\r\nfunction onload()\r\n{\r\n  console.log('Page loaded.');\r\n  \r\n  canvas = document.getElementById('warehouse');\r\n  \r\n\tcanvas.width = wareWidth * tileWidth;\r\n  canvas.height = wareHeight * tileHeight;\r\n  \r\n\tcanvas.addEventListener(\"click\", canvasClick, false);\r\n\r\n\tctx = canvas.getContext(\"2d\");\r\n\r\n\tspritesheet = new Image();\r\n\tspritesheet.src = 'src/img/sprites.png';\r\n\tspritesheet.onload = loaded;\r\n}\r\n\r\n// the spritesheet is ready\r\nfunction loaded()\r\n{\r\n\tconsole.log('Spritesheet loaded.');\r\n\tspritesheetLoaded = true;\r\n\tcreateWorld();\r\n}\r\n\r\n// fill the warehouse with parcels\r\nfunction createWorld()\r\n{\r\n\tconsole.log('Creating warehouse...');\r\n\r\n\t// create emptiness\r\n\tfor (var x=0; x < wareWidth; x++)\r\n\t{\r\n\t\twarehouse[x] = [];\r\n\r\n\t\tfor (var y=0; y < wareHeight; y++)\r\n\t\t{\r\n\t\t\twarehouse[x][y] = 0;\r\n\t\t}\r\n  }\r\n  \r\n  //create deploy area\r\n  for (var x=0; x < 15; x++)\r\n\t{\r\n\t\tfor (var y=14; y < wareHeight; y++)\r\n\t\t{\r\n\t\t\tif(y==14){\r\n        warehouse[x][y] = 7;\r\n      }\r\n      else{\r\n        if(x<5){\r\n          warehouse[x][y] = 3;\r\n        }\r\n         \r\n          else if(x>=5 && x<10){\r\n            warehouse[x][y] = 4;\r\n          }\r\n          else{\r\n            warehouse[x][y] = 5;\r\n          }\r\n      }\r\n\t\t}\r\n\t}\r\n\r\n\t// scatter some walls\r\n\tfor (var x=0; x < wareWidth; x++)\r\n\t{\r\n\t\tfor (var y=0; y < 14; y++)\r\n\t\t{\r\n\t\t\tif (Math.random() > 0.98)\r\n\t\t\twarehouse[x][y] = 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// calculate initial possible path\r\n\t// note: unlikely but possible to never find one...\r\n\tcurrentPath = [];\r\n\twhile (currentPath.length == 0)\r\n\t{\r\n\t\tpathStart = [Math.floor(Math.random()*wareWidth),Math.floor(Math.random()*wareHeight)];\r\n\t\tpathEnd = [Math.floor(Math.random()*wareWidth),Math.floor(Math.random()*wareHeight)];\r\n\t\tif (warehouse[pathStart[0]][pathStart[1]] == 0)\r\n\t\tcurrentPath = findPath(warehouse,pathStart,pathEnd);\r\n\t}\r\n\tredraw();\r\n\r\n}\r\n\r\nfunction redraw()\r\n{\r\n\tif (!spritesheetLoaded) return;\r\n\r\n\tconsole.log('redrawing...');\r\n\r\n\tvar spriteNum = 0;\r\n\r\n\t// clear the screen\r\n\tctx.fillStyle = '#000000';\r\n\tctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n\tfor (var x=0; x < wareWidth; x++)\r\n\t{\r\n\t\tfor (var y=0; y < wareHeight; y++)\r\n\t\t{\r\n\r\n\t\t\t// choose a sprite to draw\r\n\t\t\tswitch(warehouse[x][y])\r\n\t\t\t{\r\n        case 7:\r\n          spriteNum = 7;\r\n          break;\r\n          case 3:\r\n          spriteNum = 3;\r\n          break;\r\n          case 5:\r\n          spriteNum = 5;\r\n          break;\r\n          case 4:\r\n          spriteNum = 4;\r\n          break;\r\n\t\t\tcase 1:\r\n\t\t\t\tspriteNum = 2;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tspriteNum = 1;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// draw it\r\n\t\t\t// ctx.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);\r\n\t\t\tctx.drawImage(spritesheet,\r\n\t\t\tspriteNum*tileWidth, 0,\r\n\t\t\ttileWidth, tileHeight,\r\n\t\t\tx*tileWidth, y*tileHeight,\r\n\t\t\ttileWidth, tileHeight);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// draw the path\r\n\tconsole.log('Current path length: '+currentPath.length);\r\n\tfor (rp=0; rp<currentPath.length; rp++)\r\n\t{\r\n\t\tswitch(rp)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tspriteNum = 1; // start\r\n\t\t\tbreak;\r\n\t\tcase currentPath.length-1:\r\n\t\t\tspriteNum = 0; // end\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tspriteNum = 6; // path node\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tctx.drawImage(spritesheet,\r\n\t\tspriteNum*tileWidth, 0,\r\n\t\ttileWidth, tileHeight,\r\n\t\tcurrentPath[rp][0]*tileWidth,\r\n\t\tcurrentPath[rp][1]*tileHeight,\r\n\t\ttileWidth, tileHeight);\r\n\t}\t\t\r\n}\r\n\r\n// handle click events on the canvas\r\nfunction canvasClick(e)\r\n{\r\n\tvar x;\r\n\tvar y;\r\n\r\n\t// grab html page coords\r\n\tif (e.pageX != undefined && e.pageY != undefined)\r\n\t{\r\n\t\tx = e.pageX;\r\n\t\ty = e.pageY;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tx = e.clientX + document.body.scrollLeft +\r\n\t\tdocument.documentElement.scrollLeft;\r\n\t\ty = e.clientY + document.body.scrollTop +\r\n\t\tdocument.documentElement.scrollTop;\r\n\t}\r\n\r\n\t// make them relative to the canvas only\r\n\tx -= canvas.offsetLeft;\r\n\ty -= canvas.offsetTop;\r\n\r\n\t// return tile x,y that we clicked\r\n\tvar cell =\r\n\t[\r\n\tMath.floor(x/tileWidth),\r\n\tMath.floor(y/tileHeight)\r\n\t];\r\n\r\n\t// now we know while tile we clicked\r\n\tconsole.log('we clicked tile '+cell[0]+','+cell[1]);\r\n\r\n\tpathStart = pathEnd;\r\n\tpathEnd = cell;\r\n\r\n\t// calculate path\r\n\tcurrentPath = findPath(warehouse,pathStart,pathEnd);\r\n\tredraw();\r\n}\r\n\r\n// world is a 2d array of integers (eg world[10][15] = 0)\r\n// pathStart and pathEnd are arrays like [5,10]\r\nfunction findPath(world, pathStart, pathEnd)\r\n{\r\n\t// shortcuts for speed\r\n\tvar\tabs = Math.abs;\r\n\tvar\tmax = Math.max;\r\n\tvar\tpow = Math.pow;\r\n\tvar\tsqrt = Math.sqrt;\r\n\r\n\t// the world data are integers:\r\n\t// anything higher than this number is considered blocked\r\n\t// this is handy is you use numbered sprites, more than one\r\n\t// of which is walkable road, grass, mud, etc\r\n\tvar maxWalkableTileNum = 0;\r\n\r\n\t// keep track of the world dimensions\r\n    // Note that this A-star implementation expects the world array to be square: \r\n\t// it must have equal height and width. If your game world is rectangular, \r\n\t// just fill the array with dummy values to pad the empty space.\r\n\tvar worldWidth = world[0].length;\r\n\tvar worldHeight = world.length;\r\n\tvar worldSize =\tworldWidth * worldHeight;\r\n\r\n\t// which heuristic should we use?\r\n\t// default: no diagonals (Manhattan)\r\n\tvar distanceFunction = ManhattanDistance;\r\n\tvar findNeighbours = function(){}; // empty\r\n\r\n\t/*\r\n\r\n\t// alternate heuristics, depending on your game:\r\n\r\n\t// diagonals allowed but no sqeezing through cracks:\r\n\tvar distanceFunction = DiagonalDistance;\r\n\tvar findNeighbours = DiagonalNeighbours;\r\n\r\n\t// diagonals and squeezing through cracks allowed:\r\n\tvar distanceFunction = DiagonalDistance;\r\n\tvar findNeighbours = DiagonalNeighboursFree;\r\n\r\n\t// euclidean but no squeezing through cracks:\r\n\tvar distanceFunction = EuclideanDistance;\r\n\tvar findNeighbours = DiagonalNeighbours;\r\n\r\n\t// euclidean and squeezing through cracks allowed:\r\n\tvar distanceFunction = EuclideanDistance;\r\n\tvar findNeighbours = DiagonalNeighboursFree;\r\n\r\n\t*/\r\n\r\n\t// distanceFunction functions\r\n\t// these return how far away a point is to another\r\n\r\n\tfunction ManhattanDistance(Point, Goal)\r\n\t{\t// linear movement - no diagonals - just cardinal directions (NSEW)\r\n\t\treturn abs(Point.x - Goal.x) + abs(Point.y - Goal.y);\r\n\t}\r\n\r\n\tfunction DiagonalDistance(Point, Goal)\r\n\t{\t// diagonal movement - assumes diag dist is 1, same as cardinals\r\n\t\treturn max(abs(Point.x - Goal.x), abs(Point.y - Goal.y));\r\n\t}\r\n\r\n\tfunction EuclideanDistance(Point, Goal)\r\n\t{\t// diagonals are considered a little farther than cardinal directions\r\n\t\t// diagonal movement using Euclide (AC = sqrt(AB^2 + BC^2))\r\n\t\t// where AB = x2 - x1 and BC = y2 - y1 and AC will be [x3, y3]\r\n\t\treturn sqrt(pow(Point.x - Goal.x, 2) + pow(Point.y - Goal.y, 2));\r\n\t}\r\n\r\n\t// Neighbours functions, used by findNeighbours function\r\n\t// to locate adjacent available cells that aren't blocked\r\n\r\n\t// Returns every available North, South, East or West\r\n\t// cell that is empty. No diagonals,\r\n\t// unless distanceFunction function is not Manhattan\r\n\tfunction Neighbours(x, y)\r\n\t{\r\n\t\tvar\tN = y - 1,\r\n\t\tS = y + 1,\r\n\t\tE = x + 1,\r\n\t\tW = x - 1,\r\n\t\tmyN = N > -1 && canWalkHere(x, N),\r\n\t\tmyS = S < worldHeight && canWalkHere(x, S),\r\n\t\tmyE = E < worldWidth && canWalkHere(E, y),\r\n\t\tmyW = W > -1 && canWalkHere(W, y),\r\n\t\tresult = [];\r\n\t\tif(myN)\r\n\t\tresult.push({x:x, y:N});\r\n\t\tif(myE)\r\n\t\tresult.push({x:E, y:y});\r\n\t\tif(myS)\r\n\t\tresult.push({x:x, y:S});\r\n\t\tif(myW)\r\n\t\tresult.push({x:W, y:y});\r\n\t\tfindNeighbours(myN, myS, myE, myW, N, S, E, W, result);\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// returns every available North East, South East,\r\n\t// South West or North West cell - no squeezing through\r\n\t// \"cracks\" between two diagonals\r\n\tfunction DiagonalNeighbours(myN, myS, myE, myW, N, S, E, W, result)\r\n\t{\r\n\t\tif(myN)\r\n\t\t{\r\n\t\t\tif(myE && canWalkHere(E, N))\r\n\t\t\tresult.push({x:E, y:N});\r\n\t\t\tif(myW && canWalkHere(W, N))\r\n\t\t\tresult.push({x:W, y:N});\r\n\t\t}\r\n\t\tif(myS)\r\n\t\t{\r\n\t\t\tif(myE && canWalkHere(E, S))\r\n\t\t\tresult.push({x:E, y:S});\r\n\t\t\tif(myW && canWalkHere(W, S))\r\n\t\t\tresult.push({x:W, y:S});\r\n\t\t}\r\n\t}\r\n\r\n\t// returns every available North East, South East,\r\n\t// South West or North West cell including the times that\r\n\t// you would be squeezing through a \"crack\"\r\n\tfunction DiagonalNeighboursFree(myN, myS, myE, myW, N, S, E, W, result)\r\n\t{\r\n\t\tmyN = N > -1;\r\n\t\tmyS = S < worldHeight;\r\n\t\tmyE = E < worldWidth;\r\n\t\tmyW = W > -1;\r\n\t\tif(myE)\r\n\t\t{\r\n\t\t\tif(myN && canWalkHere(E, N))\r\n\t\t\tresult.push({x:E, y:N});\r\n\t\t\tif(myS && canWalkHere(E, S))\r\n\t\t\tresult.push({x:E, y:S});\r\n\t\t}\r\n\t\tif(myW)\r\n\t\t{\r\n\t\t\tif(myN && canWalkHere(W, N))\r\n\t\t\tresult.push({x:W, y:N});\r\n\t\t\tif(myS && canWalkHere(W, S))\r\n\t\t\tresult.push({x:W, y:S});\r\n\t\t}\r\n\t}\r\n\r\n\t// returns boolean value (world cell is available and open)\r\n\tfunction canWalkHere(x, y)\r\n\t{\r\n\t\treturn ((world[x] != null) &&\r\n\t\t\t(world[x][y] != null) &&\r\n\t\t\t(world[x][y] <= maxWalkableTileNum));\r\n\t};\r\n\r\n\t// Node function, returns a new object with Node properties\r\n\t// Used in the calculatePath function to store route costs, etc.\r\n\tfunction Node(Parent, Point)\r\n\t{\r\n\t\tvar newNode = {\r\n\t\t\t// pointer to another Node object\r\n\t\t\tParent:Parent,\r\n\t\t\t// array index of this Node in the world linear array\r\n\t\t\tvalue:Point.x + (Point.y * worldWidth),\r\n\t\t\t// the location coordinates of this Node\r\n\t\t\tx:Point.x,\r\n\t\t\ty:Point.y,\r\n\t\t\t// the heuristic estimated cost\r\n\t\t\t// of an entire path using this node\r\n\t\t\tf:0,\r\n\t\t\t// the distanceFunction cost to get\r\n\t\t\t// from the starting point to this node\r\n\t\t\tg:0\r\n\t\t};\r\n\r\n\t\treturn newNode;\r\n\t}\r\n\r\n\t// Path function, executes AStar algorithm operations\r\n\tfunction calculatePath()\r\n\t{\r\n\t\t// create Nodes from the Start and End x,y coordinates\r\n\t\tvar\tmypathStart = Node(null, {x:pathStart[0], y:pathStart[1]});\r\n\t\tvar mypathEnd = Node(null, {x:pathEnd[0], y:pathEnd[1]});\r\n\t\t// create an array that will contain all world cells\r\n\t\tvar AStar = new Array(worldSize);\r\n\t\t// list of currently open Nodes\r\n\t\tvar Open = [mypathStart];\r\n\t\t// list of closed Nodes\r\n\t\tvar Closed = [];\r\n\t\t// list of the final output array\r\n\t\tvar result = [];\r\n\t\t// reference to a Node (that is nearby)\r\n\t\tvar myNeighbours;\r\n\t\t// reference to a Node (that we are considering now)\r\n\t\tvar myNode;\r\n\t\t// reference to a Node (that starts a path in question)\r\n\t\tvar myPath;\r\n\t\t// temp integer variables used in the calculations\r\n\t\tvar length, max, min, i, j;\r\n\t\t// iterate through the open list until none are left\r\n\t\twhile(length = Open.length)\r\n\t\t{\r\n\t\t\tmax = worldSize;\r\n\t\t\tmin = -1;\r\n\t\t\tfor(i = 0; i < length; i++)\r\n\t\t\t{\r\n\t\t\t\tif(Open[i].f < max)\r\n\t\t\t\t{\r\n\t\t\t\t\tmax = Open[i].f;\r\n\t\t\t\t\tmin = i;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// grab the next node and remove it from Open array\r\n\t\t\tmyNode = Open.splice(min, 1)[0];\r\n\t\t\t// is it the destination node?\r\n\t\t\tif(myNode.value === mypathEnd.value)\r\n\t\t\t{\r\n\t\t\t\tmyPath = Closed[Closed.push(myNode) - 1];\r\n\t\t\t\tdo\r\n\t\t\t\t{\r\n\t\t\t\t\tresult.push([myPath.x, myPath.y]);\r\n\t\t\t\t}\r\n\t\t\t\twhile (myPath = myPath.Parent);\r\n\t\t\t\t// clear the working arrays\r\n\t\t\t\tAStar = Closed = Open = [];\r\n\t\t\t\t// we want to return start to finish\r\n\t\t\t\tresult.reverse();\r\n\t\t\t}\r\n\t\t\telse // not the destination\r\n\t\t\t{\r\n\t\t\t\t// find which nearby nodes are walkable\r\n\t\t\t\tmyNeighbours = Neighbours(myNode.x, myNode.y);\r\n\t\t\t\t// test each one that hasn't been tried already\r\n\t\t\t\tfor(i = 0, j = myNeighbours.length; i < j; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tmyPath = Node(myNode, myNeighbours[i]);\r\n\t\t\t\t\tif (!AStar[myPath.value])\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// estimated cost of this particular route so far\r\n\t\t\t\t\t\tmyPath.g = myNode.g + distanceFunction(myNeighbours[i], myNode);\r\n\t\t\t\t\t\t// estimated cost of entire guessed route to the destination\r\n\t\t\t\t\t\tmyPath.f = myPath.g + distanceFunction(myNeighbours[i], mypathEnd);\r\n\t\t\t\t\t\t// remember this new path for testing above\r\n\t\t\t\t\t\tOpen.push(myPath);\r\n\t\t\t\t\t\t// mark this node in the world graph as visited\r\n\t\t\t\t\t\tAStar[myPath.value] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// remember this route as having no more untested options\r\n\t\t\t\tClosed.push(myNode);\r\n\t\t\t}\r\n\t\t} // keep iterating until the Open list is empty\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// actually calculate the a-star path!\r\n\t// this returns an array of coordinates\r\n\t// that is empty if no path is possible\r\n\treturn calculatePath();\r\n\r\n} // end of findPath() function\r\n\r\n// start running immediately\r\nonload();"]}